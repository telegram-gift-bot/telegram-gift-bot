

import re
import os
import csv
import logging
import asyncio
import sqlite3
from datetime import datetime, timedelta, timezone
from pathlib import Path
from urllib.parse import urlparse
from dateutil import parser
from aiogram import F
from math import ceil
import asyncssh
from aiogram import Bot, Dispatcher, Router, types, F
from aiogram.enums import ParseMode
from aiogram.filters import CommandStart
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.client.default import DefaultBotProperties
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from apscheduler.schedulers.asyncio import AsyncIOScheduler
import aiofiles
from utils import shorten_date
from dotenv import load_dotenv, find_dotenv


# ================== SCHEDULER ==================
scheduler = AsyncIOScheduler(timezone="UTC")

# ================== CONSTANTS & PATHS ==================
DB_PATH = Path("/root/richi_gift_bot/requests.db")
LOCAL_CSV = Path("/root/richi_gift_bot/remote_orders.csv")
LIMIT = 20

REMOTE = {
    "host": "38.180.6.162",
    "user": "root",
    "key": "/root/.ssh/id_rsa",
    "remote_csv": "/root/mk_tg_bot/orders.csv",
}

# ================== LOGGING ==================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler("bot_logs.log"),
    ],
)
logger = logging.getLogger(__name__)

# ================== ENV ==================
load_dotenv(find_dotenv(), override=True)
API_TOKEN: str | None = os.getenv("TELEGRAM_BOT_API_TOKEN")

if not API_TOKEN:
    raise RuntimeError("‚ùå TELEGRAM_BOT_API_TOKEN is not set in .env or env vars")
else:
    logger.info("‚úÖ TOKEN –∑–∞–≥—Ä—É–∂–µ–Ω —É—Å–ø–µ—à–Ω–æ")

# ================== AIOGRAM CORE ==================
bot = Bot(token=API_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())
router = Router()
dp.include_router(router)

# ================== FSM ==================
class LangFSM(StatesGroup):
    choosing = State()

# ================== DATABASE INIT ==================
def init_db() -> None:
    print(f"üìÇ –¢–µ–∫—É—â–∏–π –ø—É—Ç—å –∫ –ë–î: {DB_PATH}")  # ‚Üê –≤–æ—Ç —Å—é–¥–∞

    with sqlite3.connect(DB_PATH) as con:
        con.executescript(
            '''
            CREATE TABLE IF NOT EXISTS requests (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                shop_link TEXT NOT NULL,
                amount TEXT NOT NULL,
                note TEXT,
                reserved_by INTEGER,
                reserved_until TEXT,
                created_at TEXT DEFAULT CURRENT_TIMESTAMP
            );
            CREATE TABLE IF NOT EXISTS users (
                user_id INTEGER PRIMARY KEY,
                lang TEXT DEFAULT 'ru'
            );
            '''
        )
        con.commit()

# ====== –ê–ù–¢–ò–°–ü–ê–ú: –ø—Ä–æ–≤–µ—Ä–∫–∞ –º–∞–≥–∞–∑–∏–Ω–∞ ======
def is_spammy_shop(text: str) -> bool:
    text = text.strip().lower()
    if not text or len(text) < 3:
        return True
    if re.fullmatch(r"[^\w.]+", text):
        return True
    if text in {"asd", "test", "qwe", "aaa"}:
        return True
    if text.startswith("proverka"):
        return True
    return False

# ====== –ê–ù–¢–ò–°–ü–ê–ú: –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è ======
def is_spammy_note(note: str) -> bool:
    note = (note or "").strip()

    if note == "":
        return True

    # ‚¨áÔ∏è –†–∞–∑—Ä–µ—à–∞–µ–º —Å–∏–º–≤–æ–ª—ã "-", "‚Äî" –∫–∞–∫ –≤–∞–ª–∏–¥–Ω—ã–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏
    if note in {"-", "‚Äî"}:
        return False

    if len(note) < 3 and note.lower() not in {"ok"}:
        return True

    if re.search(r"(\d{2,3})\1{1,}", note):
        return True

    if note.lower() in {"test", "asd", "qwe", "aaa"}:
        return True

    return False

# ====== üî• –ê–ù–¢–ò–°–ü–ê–ú: –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—É–º–º—ã ======
def is_spammy_amount(amount: str) -> bool:
    amount = amount.strip().lower().replace("$", "").replace(",", "").replace(".00", "")
    
    # –ù–µ —Ü–∏—Ñ—Ä–∞ –∏–ª–∏ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π –¥–∏–∞–ø–∞–∑–æ–Ω
    if not amount or not re.fullmatch(r"\d{1,5}", amount):
        return True

    amount_int = int(amount)
    if amount_int < 10 or amount_int > 5000:
        return True

    return False
# ================== SCP DOWNLOAD ==================
async def scp_download_async() -> bool:
    try:
        async with asyncssh.connect(
            REMOTE["host"],
            username=REMOTE["user"],
            client_keys=[REMOTE["key"]],
            known_hosts=None
        ) as conn:
            await asyncssh.scp((conn, REMOTE["remote_csv"]), LOCAL_CSV)
        return True
    except Exception as e:
        logger.error("SCP download failed: %s", e)
        return False


# ================== –£–¢–ò–õ–ò–¢–´ ==================
def shorten_date(date_str: str, lang: str = "ru") -> str:
    try:
        dt = datetime.fromisoformat(date_str)
        if lang == "ru":
            return dt.strftime("%d.%m")
        else:
            return dt.strftime("%b %d")  # Jul 04
    except Exception:
        return "??.??"


def normalize_shop_name(raw_shop: str) -> str:
    raw_shop = raw_shop.strip()
    if raw_shop.startswith("http://") or raw_shop.startswith("https://"):
        netloc = urlparse(raw_shop).netloc
    elif "." in raw_shop and " " not in raw_shop:
        netloc = urlparse("https://" + raw_shop).netloc
    else:
        return raw_shop.capitalize()

    domain = netloc.replace("www.", "")
    parts = domain.split(".")
    if len(parts) >= 2:
        return parts[-2].capitalize()
    return domain.capitalize()


def format_comment(raw_note: str) -> str:
    note = raw_note.strip()
    if note.lower().startswith("almost"):
        digits = ''.join(filter(str.isdigit, note))
        return f"${digits}" if digits else note

    if 'x' in note.lower():
        parts = note.lower().split('x')
        if len(parts) == 2 and all(p.strip().isdigit() for p in parts):
            return f"{parts[0].strip()} * ${parts[1].strip()}"

    if note.startswith("$") or note.startswith("‚Ç¨"):
        return note.strip()

    if note.isdigit():
        return f"${note.strip()}"

    return note


def normalize_amount(raw_amount: str) -> str:
    raw_amount = raw_amount.strip().replace(" ", "")
    raw_amount_lower = raw_amount.lower()

    if re.fullmatch(r"(\$|‚Ç¨)\d{2,5}", raw_amount) or re.fullmatch(r"\d{2,5}‚Ç¨", raw_amount):
        return raw_amount.replace("‚Ç¨", "‚Ç¨").replace("$", "$")

    match = re.fullmatch(r"(\d{1,2})[x\*](\d{1,4})", raw_amount_lower)
    if match:
        count, value = match.groups()
        return f"{count} * ${value}"

    match = re.search(r"\d{2,5}", raw_amount)
    if match:
        value = match.group(0)
        if value == "00000" or int(value) < 10:
            return ""
        return f"${value}"

    return ""

# ================== IMPORT CSV ==================

async def import_csv():
    logger.info("üì• –ò–º–ø–æ—Ä—Ç CSV –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è")

    if not await scp_download_async():
        logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å CSV —Å —É–¥–∞–ª—ë–Ω–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞")
        return

    if not Path(LOCAL_CSV).exists():
        logger.error("‚ùå –õ–æ–∫–∞–ª—å–Ω—ã–π CSV —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return

    async with aiofiles.open(LOCAL_CSV, "r", encoding="utf-8") as f:
        content = await f.read()

    fieldnames = [
        "–ú–∞–≥–∞–∑–∏–Ω",
        "–ù–æ–º–∏–Ω–∞–ª—ã –∏ —Å—É–º–º–∞",
        "–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π",
        "–î–æ–ø. –∏–Ω—Ñ–æ",
        "–¢–µ–ª–µ–≥—Ä–∞–º",
        "–î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è",
        "–Ø–∑—ã–∫"
    ]

    rows = list(csv.DictReader(content.splitlines(), fieldnames=fieldnames))
    logger.debug(f"üîç –í—Å–µ–≥–æ —Å—Ç—Ä–æ–∫ –≤ —Ñ–∞–π–ª–µ: {len(rows)}")

    new_cnt = 0

    with sqlite3.connect(DB_PATH) as con:
        for row in rows:
            logger.debug(f"DEBUG ROW: {row}")
            try:
                raw_shop = row["–ú–∞–≥–∞–∑–∏–Ω"].strip()
                raw_amount = row["–ù–æ–º–∏–Ω–∞–ª—ã –∏ —Å—É–º–º–∞"].strip()
                raw_note = (row.get("–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π") or "").strip()

                shop_link = normalize_shop_name(raw_shop)
                amount = normalize_amount(raw_amount)
                note = format_comment(raw_note)

                # üìÖ –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞—Ç—ã –î–û —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
                created_at_raw = (row.get("–î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è") or "").strip()

                if not created_at_raw and None in row and len(row[None]) >= 6:
                    created_at_raw = row[None][5]

                try:
                    created_at_dt = parser.parse(created_at_raw)
                    created_at = created_at_dt.isoformat()
                except Exception:
                    logger.warning("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–æ–±—Ä–∞—Ç—å –¥–∞—Ç—É: %s", created_at_raw)
                    created_at = datetime.utcnow().isoformat()

                # üßº –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è (—Å –¥–∞—Ç–æ–π –≤ –ª–æ–≥–µ)
                if is_spammy_shop(shop_link) or is_spammy_amount(amount) or is_spammy_note(note):
                    logger.warning("‚õî –°–ø–∞–º-–∑–∞—è–≤–∫–∞ –ø—Ä–æ–ø—É—â–µ–Ω–∞: %s | %s | %s | %s",
                                   shop_link, amount, note, shorten_date(created_at))
                    continue

                # üîí –ü—Ä–æ–ø—É—Å–∫ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö
                exists_reserved = con.execute(
                    "SELECT 1 FROM requests WHERE shop_link=? AND amount=? AND note=? AND reserved_by IS NOT NULL",
                    (shop_link, amount, note)
                ).fetchone()

                if exists_reserved:
                    logger.info("üõë –ü—Ä–æ–ø—É—â–µ–Ω–∞ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∑–∞—è–≤–∫–∞: %s | %s", shop_link, amount)
                    continue

                # üßæ –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ç–æ—á–Ω—ã–π –¥—É–±–ª–∏–∫–∞—Ç
                exists = con.execute(
                    "SELECT 1 FROM requests WHERE shop_link=? AND amount=? AND note=? AND created_at=?",
                    (shop_link, amount, note, created_at)
                ).fetchone()

                if not exists:
                    con.execute(
                        "INSERT INTO requests (shop_link, amount, note, created_at) VALUES (?, ?, ?, ?)",
                        (shop_link, amount, note, created_at)
                    )
                    logger.info("‚ûï –ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞: %s | %s | %s", shop_link, amount, shorten_date(created_at))
                    new_cnt += 1

            except Exception as e:
                logger.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å—Ç—Ä–æ–∫–∏: %s ‚Äî %s", row, e, exc_info=True)

        con.commit()

    if new_cnt:
        logger.info("‚úÖ –ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ –Ω–æ–≤—ã—Ö –∑–∞—è–≤–æ–∫: %s", new_cnt)
    else:
        logger.info("‚ÑπÔ∏è –ù–æ–≤—ã—Ö –∑–∞—è–≤–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")

# ================== GLOBAL STORAGE ==================
user_messages = {}

# ================== SCHEDULER ==================
def schedule_release(rid, until):
    delay = (until - datetime.now(timezone.utc)).total_seconds()

    async def release_job():
        with sqlite3.connect(DB_PATH) as con:
            con.execute(
                "UPDATE requests SET reserved_by=NULL, reserved_until=NULL WHERE id=? AND reserved_until <= ?",
                (rid, datetime.now(timezone.utc).isoformat())
            )
            con.commit()
        print(f"üîì Auto-released RID={rid}")

    job_id = f"release_{rid}"
    scheduler.add_job(
        lambda: asyncio.create_task(release_job()),
        trigger="date",
        run_date=until,
        id=job_id,
        replace_existing=True
    )
    print(f"‚è∞ Scheduled auto-release in {int(delay)}s")

def schedule_reminder(rid: int, uid: int):
    remind_at = datetime.now(timezone.utc) + timedelta(hours=24)

    async def remind_job():
        lang = get_lang(uid)
        text = lang_text(
            lang,
            f"üîî –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ: –æ—Å—Ç–∞–ª–æ—Å—å 24 —á, —á—Ç–æ–±—ã –∑–∞–≤–µ—Ä—à–∏—Ç—å –∑–∞—è–≤–∫—É #{rid}.\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –µ—ë –≤ —Ä–∞–∑–¥–µ–ª–µ üìã –ú–æ–∏ –∑–∞—è–≤–∫–∏.",
            f"üîî Reminder: 24 h left to finish request #{rid}.\nCheck it in üìã My Requests."
        )
        try:
            await bot.send_message(uid, text)
            print(f"üîî Reminder sent to UID={uid} for RID={rid}")
        except Exception as e:
            print(f"‚ö†Ô∏è Failed to send reminder: {e}")

    job_id = f"remind_{rid}"
    scheduler.add_job(
        lambda: asyncio.create_task(remind_job()),
        trigger="date",
        run_date=remind_at,
        id=job_id,
        replace_existing=True
    )
    print(f"‚è∞ Scheduled reminder at {remind_at.isoformat()}")

# ================== STATE HANDLER ==================
@router.callback_query(F.data.in_({"lang_ru", "lang_en"}))
async def set_language(cb: types.CallbackQuery, state: FSMContext):
    lang = "ru" if cb.data == "lang_ru" else "en"

    with sqlite3.connect(DB_PATH) as con:
        con.execute(
            "INSERT OR REPLACE INTO users (user_id, lang) VALUES (?, ?)",
            (cb.from_user.id, lang)
        )
        con.commit()

    await state.clear()
    await show_main_menu(cb.message.chat.id, cb.from_user.id, cb.message)
    await cb.answer()


# ================== BROWSE CALLBACK ==================
@router.callback_query(F.data.startswith("browse:"))
async def cb_browse(callback: types.CallbackQuery):
    uid = callback.from_user.id
    lang = get_lang(uid)

    try:
        offset = int(callback.data.split(":")[1])
    except (ValueError, IndexError):
        await callback.answer(
            lang_text(lang, "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç", "Invalid format"),
            show_alert=True
        )
        return

    await delete_old_messages(bot, callback.message.chat.id, uid)
    await show_requests(callback.message.chat.id, uid, offset)
    await callback.answer()

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def base_kb(lang: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(
                    text=lang_text(lang, "üìã –ú–æ–∏ –∑–∞—è–≤–∫–∏", "üìã My Requests"),
                    callback_data="my_requests"
                ),
                InlineKeyboardButton(
                    text=lang_text(lang, "üîÑ –û–±–Ω–æ–≤–∏—Ç—å", "üîÑ Refresh"),
                    callback_data="refresh"
                ),
            ]
        ]
    )

def main_menu_kb(lang: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(
                    text=lang_text(lang, "üìã –ú–æ–∏ –∑–∞—è–≤–∫–∏", "üìã My Requests"),
                    callback_data="my_requests"
                )
            ],
            [
                InlineKeyboardButton(
                    text=lang_text(lang, "üì¶ –í—Å–µ –∑–∞—è–≤–∫–∏", "üì¶ All Requests"),
                    callback_data="browse:0"
                )
            ]
        ]
    )

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –õ–û–ö–ê–õ–ò–ó–ê–¶–ò–Ø ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def lang_text(lang: str, ru: str, en: str) -> str:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—Å—Ç –Ω–∞ –Ω—É–∂–Ω–æ–º —è–∑—ã–∫–µ."""
    return ru if lang == "ru" else en

def get_lang(user_id: int) -> str:
    """–ü–æ–ª—É—á–∞–µ—Ç —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –ë–î, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 'ru'."""
    with sqlite3.connect(DB_PATH) as con:
        row = con.execute("SELECT lang FROM users WHERE user_id=?", (user_id,)).fetchone()
        return row[0] if row else "ru"

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –£–î–ê–õ–ï–ù–ò–ï –°–¢–ê–†–´–• –°–û–û–ë–©–ï–ù–ò–ô ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def delete_old_messages(bot: Bot, chat_id: int, user_id: int):
    messages = user_messages.get(user_id, [])
    for msg_id in messages:
        try:
            await bot.delete_message(chat_id, msg_id)
        except Exception:
            pass  # –Ω–∞–ø—Ä–∏–º–µ—Ä, —Å–æ–æ–±—â–µ–Ω–∏–µ —É–∂–µ —É–¥–∞–ª–µ–Ω–æ
    user_messages[user_id] = []

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def generate_my_request_text(shop: str, amount: str, note: str, created_at: str, reserved_until: str) -> str:
    """–§–æ—Ä–º–∏—Ä—É–µ—Ç —Ç–µ–∫—Å—Ç –∑–∞—è–≤–∫–∏ –¥–ª—è '–ú–æ–∏—Ö –∑–∞—è–≤–æ–∫'."""
    domain = shop.replace("www.", "")
    if "." not in domain:
        domain += ".com"
    display_amount = amount if "$" in amount else f"${amount}"
    text = f"üåê –°–∞–π—Ç: {domain}\nüíµ –°—É–º–º–∞ –∑–∞–∫–∞–∑–∞: {display_amount}"

    if note and note.lower() not in {"-", "–±–µ–∑ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤", "no comments"}:
        text += f"\nüîπ –ù–æ–º–∏–Ω–∞–ª—ã: {note}"

    if created_at:
        try:
            date_str = datetime.fromisoformat(created_at).strftime("%d.%m.%Y %H:%M")
            text += f"\nüìÖ –î–æ–±–∞–≤–ª–µ–Ω–æ: {date_str}"
        except Exception:
            pass

    try:
        r_until = datetime.fromisoformat(reserved_until)
        left = r_until - datetime.now(timezone.utc)
        if left.total_seconds() > 0:
            hours = int(left.total_seconds() // 3600)
            minutes = int((left.total_seconds() % 3600) // 60)
            text += f"\n‚è≥ –û—Å—Ç–∞–ª–æ—Å—å: {hours}—á {minutes}–º"
        else:
            text += "\n‚è≥ –í—Ä–µ–º—è –±—Ä–æ–Ω–∏ –∏—Å—Ç–µ–∫–ª–æ"
    except Exception:
        pass

    return text

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ó–ê–Ø–í–ö–ò: –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ 2√óN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def format_shop_title(shop_link: str) -> str:
    parts = shop_link.replace("www.", "").split(".")
    return parts[0].capitalize() if parts else shop_link.capitalize()

# ---------- –ú–û–ò –ó–ê–Ø–í–ö–ò: generate_request_buttons ----------
def generate_request_buttons(
    requests: list[dict],
    lang: str = "ru",
    offset: int = 0,
    total: int = 0,
    my: bool = False
) -> InlineKeyboardMarkup:
    buttons, row = [], []

    for req in requests:
        rid = req["id"]
        shop_title = format_shop_title(req["shop_link"])
        amount = req["amount"] if "$" in req["amount"] else f"${req['amount']}"
        created_at = req.get("created_at")
        date_str = shorten_date(created_at, lang) if created_at else "??.??"
        print(f"‚û°Ô∏è created_at: {created_at} ‚Üí {date_str}")
        text = f"üßæ {shop_title} | {amount} | {date_str}"
        if my:
            buttons.append([
                InlineKeyboardButton(text=text, callback_data=f"my:{rid}:{offset}")
            ])
        else:
            row.append(
                InlineKeyboardButton(
                    text=text,
                    callback_data=f"view:{rid}:{offset}"
                )
            )
            if len(row) == 2:
                buttons.append(row)
                row = []

    if row:
        buttons.append(row)

    nav_row = []
    if offset >= LIMIT:
        nav_row.append(
            InlineKeyboardButton(
                text=lang_text(lang, "‚Üê –ù–∞–∑–∞–¥", "‚Üê Back"),
                callback_data=("mybrowse:" if my else "browse:") + str(offset - LIMIT)
            )
        )
    if offset + LIMIT < total:
        nav_row.append(
            InlineKeyboardButton(
                text=lang_text(lang, "–í–ø–µ—Ä—ë–¥ ‚Üí", "Next ‚Üí"),
                callback_data=("mybrowse:" if my else "browse:") + str(offset + LIMIT)
            )
        )
    if nav_row:
        buttons.append(nav_row)

    buttons.append([
        InlineKeyboardButton(
            text=lang_text(lang, "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", "‚¨ÖÔ∏è Back to menu"),
            callback_data="to_main_menu"
        )
    ])

    return InlineKeyboardMarkup(inline_keyboard=buttons)

# ---------- –ú–û–Ø –ó–ê–Ø–í–ö–ê –ü–û–î–†–û–ë–ù–û ----------
@router.callback_query(F.data.startswith("my:"))
async def cb_my_request_detail(callback: types.CallbackQuery):
    uid = callback.from_user.id
    lang = get_lang(uid)

    try:
        rid, offset = map(int, callback.data.split(":")[1:])
    except ValueError:
        await callback.answer(
            lang_text(lang, "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç", "Invalid format"),
            show_alert=True
        )
        return

    with sqlite3.connect(DB_PATH) as con:
        row = con.execute(
            """
            SELECT shop_link, amount, note, reserved_until, created_at
            FROM requests
            WHERE id=? AND reserved_by=?
            """,
            (rid, uid),
        ).fetchone()

    if not row:
        await callback.answer(
            lang_text(lang, "–ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", "Request not found"),
            show_alert=True
        )
        return

    shop, amount, note, r_until, created_at = row
    text = generate_my_request_text(shop, amount, note, created_at, r_until)

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(
                text=lang_text(lang, "‚è≥ –ü—Ä–æ–¥–ª–∏—Ç—å", "‚è≥ Extend"),
                callback_data=f"renew:{rid}:my"
            ),
            InlineKeyboardButton(
                text=lang_text(lang, "‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –±—Ä–æ–Ω—å", "‚ùå Cancel"),
                callback_data=f"cancel:{rid}:my"
            )
        ],
        [
            InlineKeyboardButton(
                text=lang_text(lang, "‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–∞—Ä—Ç—É", "‚úÖ Done & Submit"),
                callback_data=f"complete:{rid}"
            )
        ]
    ])

    await delete_old_messages(bot, callback.message.chat.id, uid)

    msg = await callback.message.answer(text, reply_markup=kb)
    user_messages.setdefault(uid, []).append(msg.message_id)


# ---------- –§–£–ù–ö–¶–ò–Ø: –ü–æ–ª—É—á–µ–Ω–∏–µ –∑–∞—è–≤–æ–∫ –ø–æ –¥–∞—Ç–µ (–Ω–æ–≤—ã–µ —Å–≤–µ—Ä—Ö—É) ----------
def get_requests_page(offset: int = 0, limit: int = 20) -> list[dict]:
    with sqlite3.connect(DB_PATH) as con:
        rows = con.execute(
            """
            SELECT id, shop_link, amount, created_at
            FROM requests
            WHERE reserved_by IS NULL
            ORDER BY datetime(created_at) DESC
            LIMIT ? OFFSET ?
            """,
            (limit, offset)
        ).fetchall()

    return [
        {"id": rid, "shop_link": shop, "amount": amt, "created_at": created_at}
        for rid, shop, amt, created_at in rows
    ]

# ================== –û–ë–ù–û–í–õ–Å–ù–ù–´–ô show_requests ==================
async def show_requests(chat_id: int, user_id: int, offset: int = 0):
    now = datetime.now(timezone.utc)
    cutoff = now - timedelta(days=14)
    lang = get_lang(user_id)

    with sqlite3.connect(DB_PATH) as con:
        rows = con.execute(
            """
            SELECT id, shop_link, amount, note,
                   reserved_by, reserved_until, created_at
            FROM requests
            WHERE datetime(created_at) >= ?
            ORDER BY created_at DESC
            LIMIT ? OFFSET ?
            """,
            (cutoff.isoformat(), LIMIT, offset),
        ).fetchall()

        total = con.execute(
            "SELECT COUNT(*) FROM requests WHERE datetime(created_at) >= ?",
            (cutoff.isoformat(),)
        ).fetchone()[0]

    # üëÅ –û—Ç–±–æ—Ä —Ç–æ–ª—å–∫–æ –Ω–µ–∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∏–ª–∏ –∏—Å—Ç–µ–∫—à–∏—Ö
    visible = []
    for rid, shop, amt, note, r_by, r_until, created_at in rows:
        if r_by and r_until:
            r_until_dt = datetime.fromisoformat(r_until)
            if r_until_dt.tzinfo is None:
                r_until_dt = r_until_dt.replace(tzinfo=timezone.utc)
            if r_until_dt > now:
                continue
        visible.append((rid, shop, amt, shorten_date(created_at)))

    # üì¶ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–Ω–æ–ø–æ–∫
    buttons, row_buf = [], []
    for rid, shop, amt, date_str in visible:
        title = format_shop_title(shop)
        amount = amt if "$" in amt else f"${amt}"
        row_buf.append(InlineKeyboardButton(
            text=f"üßæ {title} | {amount} | {date_str}",
            callback_data=f"view:{rid}:{offset}"
        ))
        if len(row_buf) == 2:
            buttons.append(row_buf)
            row_buf = []
    if row_buf:
        buttons.append(row_buf)

    # üîÅ –ù–∞–≤–∏–≥–∞—Ü–∏—è
    nav_row = []
    if offset >= LIMIT:
        nav_row.append(InlineKeyboardButton(
            text=lang_text(lang, "‚Üê –ù–∞–∑–∞–¥", "‚Üê Back"),
            callback_data=f"browse:{offset - LIMIT}"
        ))
    if (offset + LIMIT) < total:
        nav_row.append(InlineKeyboardButton(
            text=lang_text(lang, "–í–ø–µ—Ä—ë–¥ ‚Üí", "Next ‚Üí"),
            callback_data=f"browse:{offset + LIMIT}"
        ))
    if nav_row:
        buttons.append(nav_row)

    # ‚Ü©Ô∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é
    buttons.append([
        InlineKeyboardButton(
            text=lang_text(lang, "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", "‚¨ÖÔ∏è Back to menu"),
            callback_data="to_main_menu"
        )
    ])

    # üìÑ –û—Ç–ø—Ä–∞–≤–∫–∞
    current_page = offset // LIMIT + 1
    total_pages = max(1, ceil(total / LIMIT))
    header = lang_text(lang, f"üóÇ –°—Ç—Ä–∞–Ω–∏—Ü–∞ {current_page} –∏–∑ {total_pages}", f"üóÇ Page {current_page} of {total_pages}")

    await delete_old_messages(bot, chat_id, user_id)
    msg = await bot.send_message(
        chat_id,
        f"{header}\n\n" + lang_text(lang, "üõç –î–æ—Å—Ç—É–ø–Ω—ã–µ –∑–∞—è–≤–∫–∏:", "üõç Available requests:"),
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    user_messages.setdefault(user_id, []).append(msg.message_id)

# ---------- –ú–û–ò –ó–ê–Ø–í–ö–ò: show_my_requests ----------
async def show_my_requests(chat_id: int, user_id: int, offset: int = 0):
    now = datetime.now(timezone.utc)
    cutoff = now - timedelta(days=14)
    lang = get_lang(user_id)

    with sqlite3.connect(DB_PATH) as con:
        rows = con.execute(
            """
            SELECT id, shop_link, amount, reserved_until, created_at
            FROM requests
            WHERE reserved_by = ? AND datetime(created_at) >= ?
            ORDER BY datetime(created_at) DESC
            LIMIT ? OFFSET ?
            """,
            (user_id, cutoff.isoformat(), LIMIT, offset),
        ).fetchall()

        total = con.execute(
            """
            SELECT COUNT(*) FROM requests
            WHERE reserved_by = ? AND datetime(created_at) >= ?
            """,
            (user_id, cutoff.isoformat()),
        ).fetchone()[0]

    # üîÅ –°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö
    requests = [
        {
            "id": rid,
            "shop_link": shop,
            "amount": amt,
            "reserved_until": r_until,
            "created_at": created_at
        }
        for rid, shop, amt, r_until, created_at in rows
    ]

    # üì¶ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–Ω–æ–ø–æ–∫
    buttons = generate_request_buttons(
        requests=requests,
        lang=lang,
        offset=offset,
        total=total,
        my=True
    )

    current_page = offset // LIMIT + 1
    total_pages = max(1, ceil(total / LIMIT))

    header = lang_text(
        lang,
        f"üìã –ú–æ–∏ –∑–∞—è–≤–∫–∏ ({len(requests)} –∏–∑ {total})\nüóÇ –°—Ç—Ä–∞–Ω–∏—Ü–∞ {current_page} –∏–∑ {total_pages}",
        f"üìã My Requests ({len(requests)} of {total})\nüóÇ Page {current_page} of {total_pages}"
    )

    await delete_old_messages(bot, chat_id, user_id)

    msg = await bot.send_message(
        chat_id,
        f"{header}\n\n" + lang_text(lang, "–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞—è–≤–∫—É –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞:", "Select a request to view:"),
        reply_markup=buttons
    )

    user_messages.setdefault(user_id, []).append(msg.message_id)

# ---------- –ú–û–ò –ó–ê–Ø–í–ö–ò: BACK ----------
@router.callback_query(F.data.startswith("browse:"))
async def cb_browse(callback: types.CallbackQuery):
    try:
        offset = int(callback.data.split(":")[1])
    except (ValueError, IndexError):
        await callback.answer(
            lang_text(get_lang(callback.from_user.id), "–ù–µ–≤–µ—Ä–Ω—ã–π —Å–¥–≤–∏–≥", "Invalid offset"),
            show_alert=True
        )
        return

    uid = callback.from_user.id
    await delete_old_messages(bot, callback.message.chat.id, uid)
    await show_requests(callback.message.chat.id, uid, offset)
    await callback.answer()

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –û–ë–†–ê–ë–û–¢–ß–ò–ö –ú–û–ò–• –ó–ê–Ø–í–û–ö ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@router.callback_query(F.data == "my_requests")
async def cb_my_requests(callback: types.CallbackQuery):
    uid = callback.from_user.id
    await show_my_requests(callback.message.chat.id, uid)
    await callback.answer()


@router.callback_query(F.data == "all_requests")
async def cb_all_requests(callback: types.CallbackQuery):
    await show_catalog(callback.message.chat.id, callback.from_user.id)
    await callback.answer()

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –û–ë–†–ê–ë–û–¢–ß–ò–ö –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–∞—Ä—Ç—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@router.callback_query(F.data == "submit_card")
async def cb_submit_card(callback: types.CallbackQuery):
    lang = get_lang(callback.from_user.id)
    chat_id = callback.message.chat.id
    uid = callback.from_user.id

    await delete_old_messages(bot, chat_id, uid)

    msg = await callback.message.answer(
        lang_text(
            lang,
            "üí≥ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –¥–∞–Ω–Ω—ã–µ –∫–∞—Ä—Ç—ã —Å—é–¥–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ–º.",
            "üí≥ Please send your card details here as a message."
        ),
        reply_markup=back_to_menu_kb(lang)
    )

    user_messages.setdefault(uid, []).append(msg.message_id)

    try:
        await callback.message.delete()
    except:
        pass


@router.callback_query(F.data == "to_main_menu")
async def cb_to_main(callback: types.CallbackQuery):
    uid = callback.from_user.id
    chat_id = callback.message.chat.id

    await delete_old_messages(bot, chat_id, uid)

    lang = get_lang(uid)

    try:
        await callback.message.delete()
    except:
        pass

    msg = await bot.send_message(
        chat_id,
        lang_text(lang, "‚ú® –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", "‚ú® Main menu:"),
        reply_markup=main_menu_kb(lang)
    )
    user_messages.setdefault(uid, []).append(msg.message_id)

    await callback.answer()



# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –û–ë–†–ê–ë–û–¢–ß–ò–ö –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Å—Ç—Ä–∞–Ω–∏—Ü ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@router.callback_query(F.data.startswith("browse:"))
async def cb_browse_requests(callback: types.CallbackQuery):
    try:
        offset = int(callback.data.split(":")[1])
    except (IndexError, ValueError):
        offset = 0
    await show_requests(callback.message.chat.id, callback.from_user.id, offset)
    await callback.answer()


@router.callback_query(F.data.startswith("cancel:"))
async def cb_cancel(callback: types.CallbackQuery):
    parts = callback.data.split(":")
    if len(parts) < 2:
        await callback.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç", show_alert=True)
        return

    rid = int(parts[1])
    back = parts[2] if len(parts) > 2 else None
    uid = callback.from_user.id
    lang = get_lang(uid)

    with sqlite3.connect(DB_PATH) as con:
        row = con.execute(
            "SELECT reserved_by FROM requests WHERE id=?", (rid,)
        ).fetchone()

        if not row:
            await callback.answer(lang_text(lang, "–ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", "Request not found"), show_alert=True)
            return

        if row[0] != uid:
            await callback.answer(lang_text(lang, "–≠—Ç–æ –Ω–µ –≤–∞—à–∞ –∑–∞—è–≤–∫–∞", "This is not your request"), show_alert=True)
            return

        con.execute(
            "UPDATE requests SET reserved_by=NULL, reserved_until=NULL WHERE id=?",
            (rid,)
        )
        con.commit()

    await callback.answer(lang_text(lang, "–ë—Ä–æ–Ω—å —Å–Ω—è—Ç–∞", "Reservation canceled"), show_alert=True)

    if back == "my":
        await show_my_requests(callback.message.chat.id, uid)

@router.callback_query(F.data.startswith("view:"))
async def cb_view(callback: types.CallbackQuery):
    try:
        _, rid_str, offset = callback.data.split(":")
        rid = int(rid_str)
    except (ValueError, IndexError):
        await callback.answer("Invalid ID", show_alert=True)
        return

    uid  = callback.from_user.id
    lang = get_lang(uid)

    await delete_old_messages(bot, callback.message.chat.id, uid)

    with sqlite3.connect(DB_PATH) as con:
        row = con.execute(
            """SELECT shop_link, amount, note,
                     reserved_by, reserved_until, created_at
               FROM requests WHERE id=?""",
            (rid,)
        ).fetchone()

    if not row:
        await callback.answer(lang_text(lang,"–ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞","Request not found"), show_alert=True)
        return

    shop, amount, note, reserved_by, reserved_until, created_at = row
    text = generate_my_request_text(shop, amount, note, created_at, reserved_until)

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(
            text=lang_text(lang,"üë• –ó–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å","üë• Reserve"),
            callback_data=f"reserve:{rid}:{offset}"
        )],
        [InlineKeyboardButton(
            text=lang_text(lang,"‚¨ÖÔ∏è –ù–∞–∑–∞–¥","‚¨ÖÔ∏è Back"),
            callback_data=f"browse:{offset}"
        )]
    ])

    msg = await bot.send_message(callback.message.chat.id, text, reply_markup=kb)
    user_messages.setdefault(uid, []).append(msg.message_id)

    await callback.answer()

@router.callback_query(F.data.startswith("page:"))
async def cb_page(callback: types.CallbackQuery):
    pass

# ---------- –±—Ä–æ–Ω—å ----------
# ================== CALLBACK HANDLERS ==================

@router.callback_query(F.data.startswith("reserve:"))
async def cb_reserve(callback: types.CallbackQuery):
    print(f"‚úÖ Reserve clicked: {callback.data}")
    try:
        _, rid_str, offset = callback.data.split(":")
        rid = int(rid_str)
    except (ValueError, IndexError):
        print("‚ùå Failed to parse callback data")
        await callback.answer("Invalid format", show_alert=True)
        return

    uid = callback.from_user.id
    until = datetime.now(timezone.utc) + timedelta(days=2)
    print(f"‚ÑπÔ∏è Reserve for UID={uid}, RID={rid}, until={until}")

    with sqlite3.connect(DB_PATH) as con:
        row = con.execute(
            "SELECT reserved_by, reserved_until FROM requests WHERE id=?", (rid,)
        ).fetchone()
        print(f"üì¶ DB row: {row}")

        if row and row[0] and row[0] != uid and row[1]:
            reserved_until_dt = datetime.fromisoformat(row[1])
            if reserved_until_dt.tzinfo is None:
                reserved_until_dt = reserved_until_dt.replace(tzinfo=timezone.utc)

            if reserved_until_dt > datetime.now(timezone.utc):
                print("‚õî Already reserved by someone else")
                await callback.answer(
                    lang_text(get_lang(uid), "‚õî –£–∂–µ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∞", "‚õî Already reserved"),
                    show_alert=True
                )
                return

        print("üîÅ Updating reservation in DB")
        con.execute(
            "UPDATE requests SET reserved_by=?, reserved_until=? WHERE id=?",
            (uid, until.isoformat(), rid)
        )
        con.commit()

    print("‚è∞ Scheduling release/reminder‚Ä¶")
    schedule_release(rid, until)
    schedule_reminder(rid, uid)

    await callback.message.edit_reply_markup(reply_markup=None)

    await callback.answer(
        lang_text(get_lang(uid), "‚úÖ –ó–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–æ –Ω–∞ 48 —á", "‚úÖ Reserved for 48 h"),
        show_alert=True
    )

    if offset == "my":
        await show_my_requests(callback.message.chat.id, uid)
    else:
        await show_requests(callback.message.chat.id, uid, int(offset))

    print("‚úÖ reserve handler –∑–∞–≤–µ—Ä—à–∏–ª—Å—è –±–µ–∑ –æ—à–∏–±–æ–∫")

# ---------- –ø—Ä–æ–¥–ª–µ–Ω–∏–µ ----------
@router.callback_query(F.data.startswith("renew:"))
async def cb_renew(callback: types.CallbackQuery):
    print(f"‚ôªÔ∏è Renew clicked: {callback.data}")
    try:
        _, rid_str, offset = callback.data.split(":")
        rid = int(rid_str)
    except (ValueError, IndexError):
        print("‚ùå Failed to parse callback data")
        await callback.answer("Invalid format", show_alert=True)
        return

    uid = callback.from_user.id
    until = datetime.now(timezone.utc) + timedelta(days=2)
    print(f"üîÅ Renewing reservation UID={uid}, RID={rid}, until={until}")

    with sqlite3.connect(DB_PATH) as con:
        row = con.execute(
            "SELECT reserved_by FROM requests WHERE id=?", (rid,)
        ).fetchone()
        if not row or row[0] != uid:
            await callback.answer(
                lang_text(get_lang(uid), "‚õî –í—ã –Ω–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–ª–∏", "‚õî You didn't reserve this"),
                show_alert=True
            )
            return

        con.execute(
            "UPDATE requests SET reserved_until=? WHERE id=?",
            (until.isoformat(), rid)
        )
        con.commit()

    schedule_release(rid, until)
    schedule_reminder(rid, uid)

    await callback.answer(
        lang_text(get_lang(uid), "‚úÖ –ë—Ä–æ–Ω—å –ø—Ä–æ–¥–ª–µ–Ω–∞ –Ω–∞ 48 —á", "‚úÖ Reservation extended for 48 h"),
        show_alert=True
    )

    if offset == "my":
        await show_my_requests(callback.message.chat.id, uid)
    else:
        await show_requests(callback.message.chat.id, uid, int(offset))

    print("‚úÖ renew handler –∑–∞–≤–µ—Ä—à–∏–ª—Å—è –±–µ–∑ –æ—à–∏–±–æ–∫")


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –û–ë–†–ê–ë–û–¢–ß–ò–ö ‚Äú–ó–∞–Ω—è—Ç–æ‚Äù ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ noop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@router.callback_query(F.data == "noop")
async def cb_noop(cb: types.CallbackQuery):
    lang = get_lang(cb.from_user.id)
    await cb.answer(
        lang_text(lang, "‚õî –ó–∞–Ω—è—Ç–æ", "‚õî Busy"),
        show_alert=True
    )


# ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –§–£–ù–ö–¶–ò–Ø –ü–û–ö–ê–ó–ê –ì–õ–ê–í–ù–û–ì–û –ú–ï–ù–Æ ‚îê
async def show_main_menu(chat_id: int, user_id: int, edit_message: types.Message | None = None):
    lang = get_lang(user_id)

    try:
        if edit_message:
            await edit_message.edit_text(
                lang_text(lang, "‚ú® –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", "‚ú® Main menu:"),
                reply_markup=main_menu_kb(lang)
            )
        else:
            await delete_old_messages(bot, chat_id, user_id)
            msg = await bot.send_message(
                chat_id,
                lang_text(lang, "‚ú® –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", "‚ú® Main menu:"),
                reply_markup=main_menu_kb(lang)
            )
            user_messages.setdefault(user_id, []).append(msg.message_id)
    except Exception:
        await delete_old_messages(bot, chat_id, user_id)
        msg = await bot.send_message(
            chat_id,
            lang_text(lang, "‚ú® –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", "‚ú® Main menu:"),
            reply_markup=main_menu_kb(lang)
        )
        user_messages.setdefault(user_id, []).append(msg.message_id)


# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî –û–ë–†–ê–ë–û–¢–ß–ò–ö /start ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
@router.message(CommandStart())
async def cmd_start(message: types.Message, state: FSMContext):
    uid = message.from_user.id

    # üßπ –°–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏—è FSM
    await state.clear()

    # üì§ –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
    await show_main_menu(message.chat.id, uid)


# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî DEBUG CALLBACK (—Ç–æ–ª—å–∫–æ –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞) ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
DEV_IDS = {517044272}  # ‚Üê —Å—é–¥–∞ –≤–ø–∏—à–∏ —Å–≤–æ–π Telegram ID

@router.callback_query()
async def debug_cb(cb: types.CallbackQuery):
    if cb.from_user.id in DEV_IDS:
        print("üì© Callback data:", cb.data)
        await cb.answer("üì© Debug callback", show_alert=True)
    else:
        # –ù–µ —Ç—Ä–µ–≤–æ–∂–∏–º –æ–±—ã—á–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        logger.warning("‚ö†Ô∏è –ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π callback –æ—Ç UID=%s: %s", cb.from_user.id, cb.data)
        await cb.answer()


# ================== MAIN ==================
async def main():
    logger.info("‚öôÔ∏è –ó–∞–ø—É—Å–∫ init_db()")
    init_db()

    scheduler.start()
    scheduler.add_job(import_csv, trigger="interval", minutes=5, id="auto_import", replace_existing=True)

    logger.info("üîß –ë–æ—Ç –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...")
    await bot.delete_webhook(drop_pending_updates=True)

    me = await bot.me()
    logger.info("ü§ñ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∫–∞–∫ @%s", me.username)

    await import_csv()  # –≤—Ä—É—á–Ω—É—é –ø–æ–¥–≥—Ä—É–∂–∞–µ–º CSV

    # ‚¨áÔ∏è –í–ê–ñ–ù–û: –∑–∞–ø—É—Å–∫ –ø–æ–ª–ª–∏–Ω–≥–∞, —á—Ç–æ–±—ã –±–æ—Ç –Ω–∞—á–∞–ª —Å–ª—É—à–∞—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
    await dp.start_polling(bot)

# ‚¨áÔ∏è –≠—Ç–æ—Ç –±–ª–æ–∫ –î–û–õ–ñ–ï–ù –ë–´–¢–¨
if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
